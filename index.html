<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pluribus Title Scene</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Montserrat', sans-serif; 
        }
        canvas { display: block; position: absolute; top: 0; left: 0; }
        
        /* 底部状态栏 */
        #status-bar {
            position: absolute; bottom: 30px; width: 100%;
            text-align: center; color: #444; pointer-events: none; 
            font-size: 10px; letter-spacing: 2px; text-transform: uppercase;
            opacity: 0; /* 初始隐藏，播放后显示 */
            transition: opacity 1s;
        }

        /* 全屏遮罩层 - 用于引导用户点击 */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); /* 半透明黑背景 */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 10;
            transition: opacity 0.8s ease-out;
            cursor: pointer;
        }

        /* 按钮样式 */
        #start-btn {
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 15px 40px;
            color: white;
            font-family: 'Montserrat', sans-serif;
            font-weight: 900;
            font-size: 14px;
            letter-spacing: 6px;
            text-transform: uppercase;
            background: transparent;
            cursor: pointer;
            transition: all 0.3s;
        }

        #start-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }
        
        #overlay p {
            color: #888;
            font-size: 10px;
            letter-spacing: 2px;
            margin-top: 15px;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <canvas id="canvas1"></canvas>
    
    <audio id="bgm" src="pluribus_music.mp3" loop></audio>
    
    <div id="overlay">
        <div id="start-btn">Initialize System</div>
        <p>Click to Enable Audio</p>
    </div>

    <div id="status-bar"> Developed by Gunner </div>

    <script>
        const canvas = document.getElementById('canvas1');
        const ctx = canvas.getContext('2d');

        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        setCanvasSize();

        let particles = []; 
        let waves = [];
        let frameCount = 0;
        let fontLoaded = false;
        let hasInitialized = false; // guard to avoid missing the first init
        let audioStarted = false;
        const FONT_READY_FALLBACK_MS = 1800;

        const config = {
            waveSpeed: 6, 
            waveFrequency: 140, 
            waveStrength: 2.0,   
            waveBandWidth: 50,   
            bgGridGap: 26,       
            
            textureSpacing: 11,     
            textureThickness: 1.4,  
            textBaseJitter: 0.6,    
            bgAlpha: 0.9,           
            
            gapScaleX: 1.1, 
            gapScaleY: 1.3, 
            
            additiveParticleCount: 0, 
            pCenterX: 0, pCenterY: 0
        };

        // --- 粒子类 ---
        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.baseX = x;
                this.baseY = y;
                this.type = type; 
                
                if (this.type === 'TEXT') {
                    this.size = Math.random() * 1.3 + 0.7; 
                    this.baseAlpha = 0.95; 
                    this.friction = 0.15; 
                } else {
                    this.size = Math.random() * 1.2 + 0.3;
                    this.baseAlpha = config.bgAlpha;
                    this.friction = 0.90; 
                }
                this.currentAlpha = this.baseAlpha;
            }

            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.currentAlpha})`;
                if (this.type === 'BG') {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            drawText() {
                 if (this.type === 'TEXT') {
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.currentAlpha})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            update() {
                this.currentAlpha = this.baseAlpha;
                let totalPushX = 0;
                let totalPushY = 0;

                if (this.type === 'TEXT') {
                    totalPushX += (Math.random() - 0.5) * config.textBaseJitter;
                    totalPushY += (Math.random() - 0.5) * config.textBaseJitter;
                }

                for (let wave of waves) {
                    let dx = this.x - wave.x;
                    let dy = this.y - wave.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    let distDiff = Math.abs(dist - wave.radius);
                    
                    if (distDiff < config.waveBandWidth) {
                        let forceFactor = 1 - (distDiff / config.waveBandWidth);
                        forceFactor = Math.pow(forceFactor, 2); 

                        let targetX = wave.x + (dx / dist) * wave.radius;
                        let targetY = wave.y + (dy / dist) * wave.radius;
                        let pullX = targetX - this.x;
                        let pullY = targetY - this.y;

                        let strength = this.type === 'TEXT' ? 0 : config.waveStrength;
                        
                        totalPushX += pullX * strength * forceFactor;
                        totalPushY += pullY * strength * forceFactor;
                    }
                }
                
                this.x += totalPushX;
                this.y += totalPushY;
                
                let dxBase = this.x - this.baseX;
                let dyBase = this.y - this.baseY;
                this.x -= dxBase * this.friction;
                this.y -= dyBase * this.friction;
            }
        }

        // --- 声波类 ---
        class Wave {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = Math.max(canvas.width, canvas.height) * 1.2;
            }
            update() {
                this.radius += config.waveSpeed;
            }

            drawVisuals() {
                const lifePercent = this.radius / this.maxRadius;
                if (lifePercent > 1) return;
                
                const alpha = config.bgAlpha * (1 - lifePercent * 0.5);
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;

                const densityFactor = 0.25; 
                const particleCount = 5 + Math.floor(this.radius * densityFactor);

                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    let scatter = (Math.random() - 0.5 + Math.random() - 0.5) * 18; 
                    let finalRadius = this.radius + scatter;
                    let px = this.x + Math.cos(angle) * finalRadius;
                    let py = this.y + Math.sin(angle) * finalRadius;

                    let size = Math.random() * 1.2 + 0.3;
                    ctx.beginPath();
                    ctx.arc(px, py, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function init(allowFallbackFont = false) {
            if (!fontLoaded && !allowFallbackFont) return; 

            setCanvasSize();
            hasInitialized = true;

            particles = [];
            waves = [];

            let fontSize = Math.min(canvas.width / 6, 200); 
            ctx.font = '900 ' + fontSize + 'px "Montserrat", sans-serif';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            
            const fullText = "PLUR1BUS";
            const totalWidth = ctx.measureText(fullText).width;
            let currentX = (canvas.width - totalWidth) / 2; 
            const centerY = canvas.height / 2;

            let letterEllipses = [];
            ctx.textAlign = 'left'; 

            for (let i = 0; i < fullText.length; i++) {
                let char = fullText[i];
                let charWidth = ctx.measureText(char).width;
                let cx = currentX + charWidth / 2;
                let cy = centerY;
                let rx = (charWidth / 2) * config.gapScaleX;
                let ry = (fontSize / 2) * config.gapScaleY;

                letterEllipses.push({
                    cx: cx, cy: cy,
                    invRxSq: 1 / (rx * rx),
                    invRySq: 1 / (ry * ry)
                });
                currentX += charWidth;
            }
            ctx.textAlign = 'center'; 

            let pWidth = ctx.measureText("P").width;
            let startX = (canvas.width - totalWidth) / 2;
            config.pCenterX = startX + pWidth / 2;
            config.pCenterY = centerY;

            for (let y = 0; y < canvas.height; y += config.bgGridGap) {
                for (let x = 0; x < canvas.width; x += config.bgGridGap) {
                    let insideAnyEllipse = false;
                    for (let i = 0; i < letterEllipses.length; i++) {
                        let e = letterEllipses[i];
                        let dx = x - e.cx;
                        let dy = y - e.cy;
                        if ((dx * dx) * e.invRxSq + (dy * dy) * e.invRySq <= 1.0) {
                            insideAnyEllipse = true;
                            break; 
                        }
                    }
                    if (!insideAnyEllipse) {
                        let offsetX = (Math.random() - 0.5) * 15;
                        let offsetY = (Math.random() - 0.5) * 15;
                        particles.push(new Particle(x + offsetX, y + offsetY, 'BG'));
                    }
                }
            }

            let pText = "P";
            let restText = "LUR1BUS";
            let restWidth = ctx.measureText(restText).width;

            function scanText(text, x, y) {
                ctx.fillStyle = 'white';
                ctx.fillText(text, x, y);
                let data = ctx.getImageData(0, 0, canvas.width, canvas.height);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return data;
            }
            let pData = scanText(pText, config.pCenterX, config.pCenterY);
            let restData = scanText(restText, startX + pWidth + restWidth/2, config.pCenterY);

            function createTextParticles(imageData) {
                const step = 2; 
                for (let y = 0; y < imageData.height; y += step) {
                    for (let x = 0; x < imageData.width; x += step) {
                        let isTextPixel = imageData.data[(y * 4 * imageData.width) + (x * 4) + 3] > 128;
                        if (isTextPixel) {
                            let dx = x - config.pCenterX;
                            let dy = y - config.pCenterY;
                            let organic = Math.sin(dy * 0.05) * 2;
                            let effectiveDist = Math.sqrt(dx*dx + Math.pow(dy * 2.0, 2)) + organic;
                            let onWaveLine = (effectiveDist) % config.textureSpacing < config.textureThickness;
                            if (onWaveLine) {
                                particles.push(new Particle(x, y, 'TEXT'));
                            }
                        }
                    }
                }
            }
            createTextParticles(pData);
            createTextParticles(restData);
        }

        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (hasInitialized) {
                frameCount++;
                if (frameCount % config.waveFrequency === 0) {
                    waves.push(new Wave(config.pCenterX, config.pCenterY));
                }
            }

            for (let i = 0; i < particles.length; i++) {
                particles[i].update();
            }
            for (let i = 0; i < particles.length; i++) {
                particles[i].draw(); 
            }
            for (let i = waves.length - 1; i >= 0; i--) {
                let w = waves[i];
                w.update();
                w.drawVisuals(); 
                if (w.radius > w.maxRadius) waves.splice(i, 1);
            }
            for (let i = 0; i < particles.length; i++) {
                particles[i].drawText(); 
            }

            requestAnimationFrame(animate);
        }

        // --- 交互与音频控制 ---
        const overlay = document.getElementById('overlay');
        const statusBar = document.getElementById('status-bar');
        const bgm = document.getElementById('bgm');

        function activateSystem() {
            if (!audioStarted) {
                bgm.play().then(() => {
                    audioStarted = true;
                    // 淡出遮罩
                    overlay.style.opacity = 0;
                    setTimeout(() => { overlay.style.display = 'none'; }, 800);
                    // 显示底部状态栏
                    statusBar.style.opacity = 0.8;
                }).catch(e => {
                    console.error("Audio failed:", e);
                });
            }
        }

        // 点击遮罩层任意位置即可开始
        overlay.addEventListener('click', activateSystem);

        window.addEventListener('resize', () => {
            init(true);
        });

        const fontReadyPromise = document.fonts ? document.fonts.ready : Promise.resolve();
        fontReadyPromise.then(function() {
            fontLoaded = true;
            init(true);
        });

        // 容错：字体加载超时或 Promise 未触发时仍尝试初始化，避免首屏空白或错乱
        setTimeout(() => {
            if (!hasInitialized) {
                init(true);
            }
        }, FONT_READY_FALLBACK_MS);

        window.addEventListener('load', () => {
            if (!hasInitialized) {
                init(true);
            }
        });

        animate();

    </script>
</body>
</html>
